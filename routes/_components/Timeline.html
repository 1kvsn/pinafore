<:Window bind:online />
<div class="timeline" role="feed" aria-label="{{label}}" on:initialized>
  <VirtualList component="{{StatusListItem}}"
               :makeProps
               items="{{statusIds}}"
               on:scrollToBottom="onScrollToBottom()"
               shown="{{initialized}}"
               footerComponent="{{LoadingFooter}}"
               showFooter="{{initialized && runningUpdate}}"
               realm="{{timeline}}"
               on:initializedVisibleItems="initialize()"
  />
</div>
<style>
  .timeline {
    min-height: 60vh;
  }
</style>
<script>
  import { store } from '../_utils/store'
  import { getTimeline } from '../_utils/mastodon/timelines'
  import { getInstanceInfo } from '../_utils/mastodon/instance'
  import StatusListItem from './StatusListItem.html'
  import LoadingFooter from './LoadingFooter.html'
  import VirtualList from './virtualList/VirtualList.html'
  import { splice, push } from 'svelte-extras'
  import { mergeStatuses } from '../_utils/statuses'
  import { mark, stop } from '../_utils/marks'
  import { timelines } from '../_static/timelines'
  import { toast } from '../_utils/toast'
  import { database } from '../_utils/database/database'
  import { StatusStream } from '../_utils/mastodon/StatusStream'

  const cachedTimelines = {}

  if (process.browser && process.env.NODE_ENV !== 'production') {
    window.cachedTimelines = cachedTimelines
  }

  const FETCH_LIMIT = 20

  export default {
    async oncreate() {
      let timeline = this.get('timeline')
      let instanceName = this.store.get('currentInstance')
      let accessToken = this.store.get('accessToken')
      let cachedStatusIds = cachedTimelines[timeline]
      if (cachedStatusIds) {
        this.set({statusIds: cachedStatusIds})
      } else {
        this.addStatuses(await this.fetchStatusesAndPossiblyFallBack())
      }
      /* no await */ getInstanceInfo(instanceName).then(instanceInfo => database.setInstanceInfo(instanceName, instanceInfo))
      let instanceInfo = await database.getInstanceInfo(instanceName)
      this._statusStream = new StatusStream(instanceInfo.urls.streaming_api, accessToken, timeline, {
        onMessage(message) {
          console.log('message', message)
        }
      })
    },
    ondestroy() {
      if (this._statusStream) {
        this._statusStream.close()
      }
      cachedTimelines[this.get('timeline')] = this.get('statusIds')
    },
    data: () => ({
      StatusListItem: StatusListItem,
      LoadingFooter: LoadingFooter,
      statusIds: [],
      runningUpdate: false,
      initialized: false
    }),
    computed: {
      makeProps: ($currentInstance) => (statusId) => database.getStatus($currentInstance, statusId),
      lastStatusId: (statusIds) => statusIds.length && statusIds[statusIds.length - 1],
      label: (timeline, $currentInstance) => {
        if (timelines[timeline]) {
          `${timelines[timeline].label} timeline for ${$currentInstance}`
        } else if (timeline.startsWith('tag/')) {
          let tag = timeline.split('/').slice(-1)[0]
          return `#${tag} timeline for ${$currentInstance}`
        } else if (timeline.startsWith('account/')) {
          let account = timeline.split('/').slice(-1)[0]
          return `Account #${account} on ${$currentInstance}`
        }
      }
    },
    store: () => store,
    components: {
      VirtualList
    },
    methods: {
      splice: splice,
      push: push,
      initialize() {
        if (this.get('initialized') || !this.get('statusIds') || !this.get('statusIds').length) {
          return
        }
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            this.set({initialized: true})
            this.fire('initialized')
          })
        })
      },
      async onScrollToBottom() {
        if (!this.get('initialized')) {
          return
        }
        if (this.get('runningUpdate')) {
          return
        }
        mark('onScrollToBottom')
        this.set({ runningUpdate: true })
        let newStatuses = await this.fetchStatusesAndPossiblyFallBack()
        this.set({ runningUpdate: false })
        this.addStatuses(newStatuses)
        stop('onScrollToBottom')
      },
      addStatuses(newStatuses) {
        if (process.env.NODE_ENV !== 'production') {
          console.log('addStatuses()')
        }
        let instanceName = this.store.get('currentInstance')
        let timeline = this.get('timeline')
        let statusIds = this.get('statusIds')
        if (!statusIds) {
          return
        }
        /* no await */ database.insertStatuses(instanceName, timeline, newStatuses)
        let newStatusIds = newStatuses.map(status => status.id)
        let merged = mergeStatuses(statusIds, newStatusIds)
        this.set({ statusIds: merged })
      },
      async fetchStatusesAndPossiblyFallBack() {
        let online = this.get('online')
        let instanceName = this.store.get('currentInstance')
        let instanceData = this.store.get('currentInstanceData')
        let timeline = this.get('timeline')
        let lastStatusId = this.get('lastStatusId')
        let statuses
        if (!online) {
          statuses = await database.getTimeline(instanceName, timeline, lastStatusId, FETCH_LIMIT)
        } else {
          try {
            statuses = await getTimeline(instanceName, instanceData.access_token, timeline, lastStatusId, FETCH_LIMIT)
            /* no await */ database.insertStatuses(instanceName, timeline, statuses)
          } catch (e) {
            console.error(e)
            toast.say('Internet request failed. Showing offline content.')
            statuses = await database.getTimeline(instanceName, timeline, lastStatusId, FETCH_LIMIT)
          }
        }
        return statuses
      }
    }
  }
</script>