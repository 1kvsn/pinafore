<div class="virtual-list-item {{shown ? 'shown' : ''}}"
     virtual-list-key="{{key}}"
     ref:node
     style="transform: translate3d(0, {{offset}}px, 0);"
>
  <:Component {component} virtualProps="{{props}}" />
</div>
<style>
  .virtual-list-item {
    position: absolute;
    top: 0;
    opacity: 0;
    pointer-events: none;
    /* will-change: transform; */ /* causes jank in mobile Firefox */
  }
  .shown {
    opacity: 1;
    pointer-events: auto;
  }
</style>
<script>
  import { virtualListStore } from '../_utils/virtualListStore'
  import { mark, stop } from '../_utils/marks'

  let updateItemHeights = {}
  let promise = Promise.resolve()
  let onIntersectionCallbacks = {}

  let intersectionObserver = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      let key = entry.target.getAttribute('virtual-list-key')
      onIntersectionCallbacks[key](entry)
    })
  })

  export default {
    oncreate() {
      let key = this.get('key')
      // TODO: implement AsyncLayout
      // TODO: implement batchUpdate
      // TODO: fix resize on media
      onIntersectionCallbacks[key] = entry => {
        console.log('onIntersection', key, entry.boundingClientRect.height)
        let rect = entry.boundingClientRect
        updateItemHeights[key] = rect.height
        promise = promise.then(() => {
          // update all item heights in one microtask batch for better perf
          let updatedKeys = Object.keys(updateItemHeights)
          if (!updatedKeys.length) {
            return
          }
          mark('batch update VirtualListItem')
          // batch all updates to itemHeights for better perf
          let itemHeights = this.store.get('itemHeights')
          for (key of updatedKeys) {
            itemHeights[key] = updateItemHeights[key]
          }
          this.store.set({
            itemHeights: itemHeights
          })
          updateItemHeights = {}
          stop('batch update VirtualListItem')
        })
        this.set({ unobserved: true })
        intersectionObserver.unobserve(this.refs.node)
      }
      intersectionObserver.observe(this.refs.node)
    },
    ondestroy() {
      let key = this.get('key')
      if (!this.get('unobserved')) {
        intersectionObserver.unobserve(this.refs.node)
      }
      delete onIntersectionCallbacks[key]
      delete updateItemHeights[key]
    },
    data: () => ({
      unobserved: false
    }),
    store: () => virtualListStore,
    computed: {
      'shown': ($itemHeights, key) => $itemHeights[key] > 0
    }
  }
</script>